\chapter{Design} \label{chap:design}
This chapter covers the design decisions taken for the Bazo Blockchain Explorer web app and the additional components necessary to run the application.

\section{Requirements for the Bazo Blockchain Explorer}
Based on the analysis performed in \ref{analysis} and meetings held with members from the financial service provider and the University of Zurich, the use cases listed in figure \ref{fig:usecase1} and the following functional requirements were elicited:

\begin{itemize}
\item \textbf{Blocks}
A user should be able to view all validated blocks of the blockchain and the information they contain. In a list-view, the most recent blocks are being displayed, identified by their respective hashes and timestamps. If a user wants to get more comprehensive information about a block, he can display one block in a detailed-view, where additional information, such as all the transaction hashes contained in this block or the address hash of the block-reward beneficiary are presented.
\item \textbf{Transactions}
Similarly to the requirement above, a user should be able to view all validated transactions that have been broadcasted by him or other users of the blockchain. Due to the Bazo system having 3 different types of transactions (Funds Transactions, Account Creation Transactions and System Configuration Transactions), different implementations for each of them have to be made. A list-view displays the most recent transactions of each type, offering information such as the sender, receiver and the amount of the transactions. Detailed views for all transaction types are needed as well, presenting more information, for example each transaction's signature or block it is contained in.
\item \textbf{Accounts}
With Bazo using an account-based model, every user that actively interacts with the blockchain owns an account. The application should maintain a state of all accounts, that gets updated with every newly mined block. A list with the most affluent accounts should be made available, as well as a detailed view of for single accounts, which displays all transactions this account was either the sender or receiver of.
\item \textbf{Search}
A user should be able to search for blockchain data using hashes. These hashes can be identifiers of blocks, transactions or accounts, with accounts having both addresses and address-hashes. A user should not need to choose what he actually searches for, meaning the application searches through all data it has collected and, in case of a hit presents the data associated with the hash to the user, and in case of a miss, notifies the user of not finding any relevant data.
\item \textbf{Navbar}
Featured on every page of the application, a navbar, that lets a user access all functionality of the website, is required. This functionality includes, among others, links to lists of blocks, transactions and accounts. The search-functionality is also located here, being available at all times to the user.
\item \textbf{Statistical Information}
The system should calculate statistical information about the network and make it available to users. This includes information such as a graphical history of transactions, or the total amount of Bazo Coins currently in the system.
\item \textbf{Admin Panel}
Only available to admins of the system, a panel that lets them change system parameters using System Configuration Transactions has to be implemented. These transactions get sent via an interface to the network, meaning no Bazo Client is running on the server of the website.
\item \textbf{Fetch and Store Blockchain Data}
The application needs to automatically gather the latest Bazo Blockchain data and save it independently from the blockchain. This data also needs to be formatted, in order to make it publicly available. 
\end{itemize}

\begin{figure}
  \includegraphics[scale=0.35]{usecase1.png}
  \centering
  \caption{Use Cases of the Block Explorer}
  \label{fig:usecase1}
\end{figure}

\section{Structure of the Service}
The main component of the Bazo Blockchain Explorer that users and admins use to view Bazo Blockchain data is a web app, which is made up of a front- and a backend. However, to run the blockchain explorer on its own, additional components beside the front- and backend components are required. Highlighted in red in figure \ref{fig:structure} are the components that were implemented as part of this thesis. The app fetches blockchain data from a database that runs independently from the blockchain miner's built-in storage. A separate database was chosen, because additional data like statistical information needs to be calculated and stored as well, which would bloat all miner's built-in databases with information, if implemented in the miner. This also makes running the website possible without having a miner running in the backend of the web app. However, this requires a component that copies data from a running Bazo mining node's storage and stores it in the new database. As mentioned above, the web app's backend accesses this database by making queries for relevant data and sending the results to the frontend to be displayed to the user. In order to fulfil the requirement of being able to send System Configuration Transactions from the application, an interface that acts as an extension for a Bazo Client is required. With the use of this interface, signing transactions without a running Bazo Client will be made possible.

\begin{figure}
  \includegraphics[scale=0.4]{system.png}
  \centering
  \caption{Structure of the Blockexplorer and Bazo Components}
  \label{fig:structure}
\end{figure}

\subsection{Trust}
The operator of the blockchain hosts the system, which in this case is connected to a miner that also belongs to the operator. Due to the open-source nature of the block explorer however, anyone can run and host a Bazo Blockchain Explorer on his or her servers and connect to a miner of choice. A discussion about whether the miners, to which the explorer connects, need to be trusted or not, is not required, since (1) the operator has no interest in presenting its users falsified data, (2) in case doubt arises about the data's authenticity, anyone can host his own explorer, and (3) from a user's perspective, the explorer only \emph{consumes} data from the blockchain. The running Bazo blockchain is therefore not affected by any block explorers.

\section{Web Application}
A web application was chosen, because of its accessibility and its convenience. Users do not need to download software or store data on their devices to inspect the blockchain. 
The user interface of the application always displays the most recent blockchain data.  In order to structurally separate the functionality and to fulfil all requirements, specific pages featuring the following content need to be included in the application:

\begin{itemize}
\item{List of Most Recent Blocks}
\item{Detailed Block}
\item{List of Most Recent Funds Transactions}
\item{Detailed Funds Transaction}
\item{List of Most Recent Account Creation Transactions}
\item{Detailed Account Creation Transaction}
\item{List of Most Recent Configuration Transaction}
\item{Detailed Configuration Transaction}
\item{List of Most Affluent Accounts}
\item{Detailed Account}
\item{Statistical Information}
\item{Administrator Panel}
\end{itemize}

From a list-view of a data-type, each individual item can be accessed. The goal is to first, provide the user with a list view of a data-type, such as blocks. Once he finds an object of interest, he clicks on the hash of the block, which is its unique identifier, and gets presented with detailed information about that object. Depending on the data-type, the user is viewing, links to related elements enable further browsing of the data. For example, on a detailed block page, a link to the detailed account page of the account that received the block reward of said block, is listed. Since all different types of blockchain data have their own data structures, custom tables for all listed pages, that contain data need to be built. In figure \ref{fig:mockup1}, a mockup of the table containing the most recent blocks is displayed. The block's hash, the timestamp when it was mined and the counters for each transaction type are listed. Each single block hash links to the detailed page of that block. On the detailed block page, all transaction hashes that are included in a block, are ordered by type and displayed in a list. Similarly on a detailed account's page, all transactions related to that account are displayed as well.

\begin{figure}
  \includegraphics[width=\linewidth]{mockup1.png}
  \centering
  \caption{Mockup of the List of Most Recent Blocks}
  \label{fig:mockup1}
\end{figure}

\subsection{Navbar and Search}

The navbar is featured on every page of the application. Figure \ref{fig:navbar} displays all possible pages that are accessible from the navbar and the their respective detailed pages. Since there are multiple types of transactions, a dropdown menu on the \emph{Transactions} button, displays links to list-views of all types of transactions. The administrator panel is also accessed from here. Included in the navbar, is the search function. A user can enter a hash and the backend of the application searches for that hash in the database. A successful search will automatically present the data to the user in the right formatting, meaning the system displays the page according to the data type of the search result. It is possible to search for blocks, all transaction types, account hashes and account addresses, since Bazo uses both hashes and addresses to identify an account.

\begin{figure}
  \includegraphics[scale=0.35]{navbarmockup.png}
  \centering
  \caption{Functionality and Links on the Navbar}
  \label{fig:navbar}
\end{figure}

\subsection{URL-Scheme}
Keeping URLs as simple as possible was a priority. Since a specific object may only be identified by its hash or its address, either is the only variable that is needed in a URL for specific objects.

\subsection{Administrator Panel}
Since there currently are five different types of System Configuration Transactions, a \emph{Submit} form for every type needs to be available on the administrator panel. Depending on which administrator is currently logged in and using the panel, account information, such as the current transaction count and public key of the administrator, do not need to be entered in the transaction forms. These values get automatically included in the transactions are are derived from the public key, the administrator entered to log in. Detailed information about the verification process can be found in \ref{verification}. The administrator enters the payload for the transaction he wishes to send and the transaction fee. The panel also displays all current system parameters and updates them after each validated System Configuration Transaction. 

\subsection{Statistical Information}
On this section of the application, users can view data about the overall health and productivity of the Bazo blockchain. A chart featuring a 14-Day transaction history visualizes how frequently the Bazo system is used, as well as shows, whether usage increases over time of operation. Information regarding total Bazo Coin supply and the total number of Bazo accounts is also provided, since viewing accounts and their balances by all users, is possible anyway. The statistical information is updated in a regular interval, to match the recent blockchain data.

\section{Database Management}
A relational database was chosen for the explorer, because the data that gets saved always has the same format. Efficiently sorting data by an attribute, is an ability that is needed in order to provide a responsive user experience. Ideally the database is hosted on the same server, as the block explorer is, to ensure optimal read and write times. 
\subsection{Data Transfer}
The component that handles the copying of all blockchain data, is integrated into the backend of the web app. In an interval defined by the operator, it checks whether any new blocks have been mined on the blockchain. 
\subsection{Database}
For every data type, a table in the database is defined. While saving each new block, every transaction contained in that block is saved in the database as well. 

\chapter{Implementation}
This chapter documents the implementation of the components listed in chapter \ref{chap:design}; Frontend, Backend and the SQL database. An additional section concerning hosting of the application on the internet is also included.
\section{Frontend}
The frontend of the application is the interface, the user interacts with. 
\subsection{HTML Templates}
To interact with the Golang-Backend of the application, Gohtml templates have been used to define the markup of the application. One one hand, this makes way for a modular view component by letting programmers define reusable HTML modules such as headers, footers or table-templates. Using templates can minimize code duplication, which in turn makes maintenance on the code an overall less risky task. On the other hand, Golang templates allow for some limited logic in the Gohtml files, which is needed for handling variables that get passed from the backend component. For example, if the passed variable is an array of integers and the goal is to display all variables in a list, golang can create a new <li> tag for every value in the array. The HTML code that gets passed to the end user after making a request contains no Golang code, since the backend renders the Gohtml template files and passed variables to a useable HTML file that can be displayed by a web browser. Except for some Bootstrap functionality mentioned in \ref{sec:uiframeworks} and one case discussed in section \ref{sec:clientside}, all rendered pages of the application are static HTML files, because for every action a user may make on the website, a request has to be made to the backend. The website aims to always display the most recent data, so storing information that may not be up to date on the client's machine in order to save bandwidth, is outweighed by the possibility of having more recent data. 

\subsubsection{Reusable Modules}
\begin{itemize}
\item \textbf{Navbar}
\item \textbf{HTML Head}
\item \textbf{Login Modal}
\item \textbf{Transaction Modal}
\item \textbf{Script Imports}
\end{itemize}

\subsection{Bootstrap} \label{sec:uiframeworks}

To style the majority of the website, Bootstrap v4 was used extensively.
\subsection{Client-Side Logic} \label{sec:clientside}

\subsubsection{Transaction Signing} \label{txsigning}
A requirement of the Bazo Blockchain Explorer is to be able to send System Configuration Transactions from the browser. 
However, since no Bazo Client should run in the backend of the application, the ability to build and sign transactions is not provided. A Bazo Client takes transaction details and the private key of the sender in order to build a transaction. Extracting only the transaction signing functionality of the Bazo Client and implementing it into the backend of the explorer would violate security constraints, since the private key would have to be sent over the network to the server. The private key should always stay with the user and never leave his device. This is where the Bazo Interface comes in place, a REST API that builds an unfinished transaction hash using the transaction details without the issuer's private key. In a second step the user enters his private key in order to sign the transaction client-side and then send it back to the Interface, which then publishes it to the network.

\begin{figure}
  \includegraphics[scale=0.35]{transactionbuilding.png}
  \centering
  \caption{Sequence Diagram of How the Application Builds and Signs Transactions}
  \label{fig:sequence1}
\end{figure}

The process is detailed in \ref{fig:sequence1}. A user enters the values that make up the transaction into HTML-input fields on the administator panel, which are linked to a Vue.js application. In this case, that would be the type of Configuration Transaction (id), the payload (new value) and the fransaction fee.When the user hits \emph{Send}, JavaScript code extracts the public key stored in a cookie (user verification is described in \ref{verificaiton}) and requests the account data concerning that user. The REST interface responds with the account information in JSON format, of which the \emph{isRoot} attribute is important. If the public key, stored in the cookie belongs to a root account, the JavaScript code builds a URL that contains all transaction data, previously entered by the user. Another request to the interface, using that URL is made, which then builds a transaction hash using the transaction data. If that hash was returned successfully, a modal opens up on the block explorer, prompting the user to enter a root private key. Using a JavaScript implementation of elliptic signing, the transaction hash gets signed with the entered private key, which results in a new, signed transaction hash and sent to the interface, along with the unsigned hash for identification purposes.


\section{Backend}
The backend of the web app is written in Golang, which is well suited for writing web applications, due to its included http and HTML packages. Since the Bazo Blockchain was also written in Golang, compability between the two programs was ensured. The program is split up into distinct files, to separate functionality. 
\subsection{Router}
The router handles all requests made to the application. On startup, the router gets initialized and registers all possible routes. Furthermore, all Gohtml templates and JavaScript files are passed to the router, so they can be rendered and used upon request.
Additionally to the built-in net/http package included in Golang, HttpRouter by Julien Schmidt has been used as well. 

In contrast to the default mux of Go's net/http package, this router supports variables in the routing pattern and matches against the request method. It also scales better.

HttpRouter makes building a routing table convenient. All routes and the functions they invoke, once called, can be listed in a well-structured way.


\subsubsection{Administrator Verification} \label{verification}

By design, only administrators of the system can successfully publish a System Configuration Transaction to the network, since only they possess a root private key that lets them sign the transactions. However, using a Bazo Client, a non-root user may still spam the network with admin-only transactions, without them ever getting accepted by the system. Therefore implementing a thorough login-system on the explorer that requests a user's private key to verify whether he has administrator rights, in order to prevent non-administrator users from trying to publish transactions to the network seemed unnecessary. This would have also meant that a private key would get send over the network to check its access rights. The chosen verification process is as follows:
Upon requesting to log in, a user enters a public key. This public key then gets sent to the Bazo Interface, where more information regarding that key is requested. One attribute of the response the interface returns, is \emph{isRoot}. If \emph{isRoot} returns true, a cookie containing the entered public key gets saved to the user's machine and the user is verified. When the user then requests the administrator panel, the public key in the cookie gets checked again and sent to the interface. If the returned \emph{isRoot} is still true, he gets access to the administrator panel. The public key contained in the cookie then gets extracted by client-side code described in \ref{txsigning}. 

\subsection{SQL-Queries}

\subsection{Data Transfer}

\subsection{Structs}
In order to store the data in the database, additional structs for all data types needed to be defined. 

\section{PSQL Database}

\subsection{Tables}

\section{Hosting}